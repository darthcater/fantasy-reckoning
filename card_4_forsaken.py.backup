"""
Card 4: The Forsaken
Track drops that became weapons and lost FAAB bids that helped rivals
"""

from datetime import datetime
from collections import defaultdict
from league_metrics import (
    calculate_league_ranking,
    calculate_playoff_comparison,
    get_playoff_teams,
    get_grade_from_percentile
)


def calculate_card_4_ecosystem(calc, team_key: str) -> dict:
    """
    Calculate Card 4: The Forsaken metrics

    Args:
        calc: FantasyWrappedCalculator instance
        team_key: Team key

    Returns:
        Dict with ecosystem analysis
    """
    team = calc.teams[team_key]
    current_week = calc.league['current_week']

    # Track players this manager dropped
    dropped_players = []

    # Track FAAB bids this manager lost
    lost_bids = []

    # Calculate NFL season start (Week 1 typically starts first Thursday of September)
    # For 2025 season, Week 1 started around September 4, 2025
    season_year = calc.league.get('season', 2025)
    season_start = datetime(season_year, 9, 4)  # Approximate Week 1 start

    # Track all transactions chronologically
    for trans in calc.transactions:
        trans_type = trans.get('type', '')
        timestamp = trans.get('timestamp', 0)

        # Parse timestamp to get week
        try:
            trans_date = datetime.fromtimestamp(timestamp)
            # Calculate week number: days since season start / 7, plus 1
            days_since_start = (trans_date - season_start).days
            trans_week = max(1, min(current_week, (days_since_start // 7) + 1))
        except:
            trans_week = 1

        # Check for drops by this manager
        for player in trans.get('players', []):
            if not isinstance(player, dict):
                continue

            player_id = str(player.get('player_id', ''))

            # Check if this manager dropped this player
            # FIX: Data is in player directly, not player['transaction_data']
            if player.get('type') == 'drop' and player.get('source_team_key') == team_key:
                # Track the drop
                dropped_players.append({
                    'player_id': player_id,
                    'drop_week': trans_week,
                    'timestamp': timestamp
                })

            # Check if this was an add by another team (could be a pickup of our drop or a lost bid)
            # FIX: Data is in player directly, not player['transaction_data']
            if player.get('type') == 'add' and player.get('destination_team_key') != team_key:
                acquiring_team = player.get('destination_team_key')
                faab_bid = player.get('faab_bid', 0)

                # Check if we dropped this player earlier
                was_our_drop = any(
                    d['player_id'] == player_id and d['timestamp'] < timestamp
                    for d in dropped_players
                )

                if was_our_drop:
                    # Calculate ROS points this player scored for the acquiring team
                    ros_points = calc.get_ros_points(player_id, trans_week)

                    # Find the drop record
                    for drop in dropped_players:
                        if drop['player_id'] == player_id and drop['timestamp'] < timestamp:
                            drop['acquired_by'] = acquiring_team
                            drop['acquired_by_name'] = calc.teams.get(acquiring_team, {}).get('manager_name', 'Unknown')
                            drop['ros_points'] = ros_points
                            drop['faab_cost_to_acquire'] = faab_bid
                            break

    # Calculate impact of drops with player names
    drops_that_hurt = []
    for drop in dropped_players:
        if drop.get('ros_points', 0) > 0:
            player_id = drop['player_id']
            player_name = calc.player_names.get(player_id, f"Player {player_id}")  # NEW: Add player name

            drops_that_hurt.append({
                'player_id': player_id,
                'player_name': player_name,  # NEW
                'drop_week': drop['drop_week'],
                'acquired_by': drop.get('acquired_by_name', 'Waiver wire'),
                'ros_points': round(drop.get('ros_points', 0), 1),
                'faab_cost': drop.get('faab_cost_to_acquire', 0),
                'context': f"Dropped week {drop['drop_week']}, went on to score {drop.get('ros_points', 0):.1f} ROS points"  # NEW: Context
            })

    # Sort by ROS points (highest impact first)
    drops_that_hurt.sort(key=lambda x: x['ros_points'], reverse=True)

    # Find optimal FA pickups this manager could have made
    optimal_fa_by_week = []

    for week in range(1, min(current_week + 1, 5)):  # Sample first 5 weeks
        week_key = f'week_{week}'

        # Get available FAs at this week
        available_fas = calc.get_available_fas(week)

        if available_fas:
            # Get top 3 FAs by ROS points
            top_fas = available_fas[:3]

            optimal_fa_by_week.append({
                'week': week,
                'top_available': [
                    {
                        'player_id': fa[0],
                        'ros_points': round(fa[1], 1)
                    }
                    for fa in top_fas
                ]
            })

    # Calculate total opportunity cost
    total_drop_impact = sum(d['ros_points'] for d in drops_that_hurt)

    # Find worst drops (top 5)
    worst_drops = drops_that_hurt[:5]

    # ====================================================================================
    # ACTUAL WAIVER WIRE CONTRIBUTION CALCULATION
    # Measure what you DID add and how it helped (not theoretical opportunity cost)
    # ====================================================================================

    # Find all players added by this manager
    added_players = []
    for trans in calc.transactions:
        if trans.get('type') not in ['add', 'trade']:
            continue

        timestamp = trans.get('timestamp', 0)
        try:
            trans_date = datetime.fromtimestamp(timestamp)
            days_since_start = (trans_date - season_start).days
            trans_week = max(1, min(current_week, (days_since_start // 7) + 1))
        except:
            trans_week = 1

        # Check for adds by this manager
        for player in trans.get('players', []):
            if not isinstance(player, dict):
                continue

            # FIX: Data is in player directly, not player['transaction_data']
            if player.get('type') == 'add' and player.get('destination_team_key') == team_key:
                player_id = str(player.get('player_id', ''))
                source_type = player.get('source_type', 'unknown')
                if player_id:
                    added_players.append({
                        'player_id': player_id,
                        'add_week': trans_week,
                        'source_type': source_type  # Track if waiver or FA
                    })

    # Calculate detailed metrics for each add
    total_points_added = 0
    total_points_started = 0
    add_details = []
    productive_adds = 0
    meaningful_starters = 0

    for add in added_players:
        player_id = add['player_id']
        add_week = add['add_week']
        player_name = calc.player_names.get(player_id, f"Player {player_id}")

        # Calculate ROS points from this add
        ros_points = 0
        points_started = 0
        weeks_started = 0
        weeks_available = 0

        for week in range(add_week, current_week + 1):
            week_key = f'week_{week}'
            weeks_available += 1

            # Get total points this player scored this week (whether started or not)
            week_points = calc.player_points_by_week.get(player_id, {}).get(week, 0)
            ros_points += week_points

            # Check if player was in starting lineup
            if week_key in calc.weekly_data.get(team_key, {}):
                week_data = calc.weekly_data[team_key][week_key]
                roster = week_data.get('roster', {})
                starters = roster.get('starters', [])

                for starter in starters:
                    if str(starter.get('player_id')) == player_id:
                        points_started += week_points
                        weeks_started += 1
                        break

        # Calculate per-game averages
        ppg = ros_points / weeks_available if weeks_available > 0 else 0
        usage_rate = weeks_started / weeks_available if weeks_available > 0 else 0

        # Productive add = averaged ≥5 PPG when started
        if weeks_started > 0:
            ppg_when_started = points_started / weeks_started
            if ppg_when_started >= 5.0:
                productive_adds += 1

        # Meaningful starter = started in ≥40% of available weeks
        if usage_rate >= 0.40:
            meaningful_starters += 1

        total_points_added += ros_points
        total_points_started += points_started

        add_details.append({
            'player_id': player_id,
            'player_name': player_name,
            'add_week': add_week,
            'ros_points': round(ros_points, 1),
            'points_started': round(points_started, 1),
            'weeks_available': weeks_available,
            'weeks_started': weeks_started,
            'ppg': round(ppg, 1),
            'usage_rate': round(usage_rate * 100, 1),
            'is_meaningful_starter': usage_rate >= 0.40
        })

    # Sort adds by ROS points (best adds first)
    add_details.sort(key=lambda x: x['ros_points'], reverse=True)

    total_adds = len(added_players)
    usage_rate_overall = (total_points_started / total_points_added * 100) if total_points_added > 0 else 0
    add_quality_score = sum(a['ppg'] for a in add_details) / len(add_details) if add_details else 0
    starter_conversion_rate = (meaningful_starters / total_adds * 100) if total_adds > 0 else 0
    efficiency_rate = (productive_adds / total_adds * 100) if total_adds > 0 else 0

    # Calculate win contribution (marginal wins from waiver adds)
    actual_wins = int(team['wins'])
    wins_without_waiver_adds = 0

    for week in range(1, current_week + 1):
        week_key = f'week_{week}'
        if week_key not in calc.weekly_data.get(team_key, {}):
            continue

        week_data = calc.weekly_data[team_key][week_key]
        actual_score = week_data.get('actual_points', 0)
        opponent_score = week_data.get('opponent_points', 0)

        # Calculate score without waiver adds
        waiver_points_this_week = 0
        starters = week_data.get('roster', {}).get('starters', [])

        for starter in starters:
            starter_id = str(starter.get('player_id'))
            # Check if this starter was a waiver add
            for add_detail in add_details:
                if add_detail['player_id'] == starter_id and add_detail['add_week'] <= week:
                    waiver_points_this_week += starter.get('points', 0)
                    break

        score_without_adds = actual_score - waiver_points_this_week

        if score_without_adds > opponent_score:
            wins_without_waiver_adds += 1

    waiver_win_contribution = actual_wins - wins_without_waiver_adds

    # ====================================================================================
    # PRIMARY METRIC: Total Waiver Points Added (League Comparison)
    # Calculate this BEFORE the haunting section so we can use gap_to_playoff
    # ====================================================================================

    # Calculate actual waiver contributions for all teams
    all_team_waiver_contributions = {}
    for tk in calc.teams.keys():
        # Get adds for this team
        tk_adds = []
        for trans in calc.transactions:
            if trans.get('type') not in ['add', 'trade']:
                continue

            for player in trans.get('players', []):
                if not isinstance(player, dict):
                    continue

                # FIX: Data is in player directly, not player['transaction_data']
                if player.get('type') == 'add' and player.get('destination_team_key') == tk:
                    player_id = str(player.get('player_id', ''))
                    if player_id:
                        try:
                            timestamp = trans.get('timestamp', 0)
                            trans_date = datetime.fromtimestamp(timestamp)
                            days_since_start = (trans_date - season_start).days
                            add_week = max(1, min(current_week, (days_since_start // 7) + 1))
                        except:
                            add_week = 1

                        tk_adds.append({
                            'player_id': player_id,
                            'add_week': add_week
                        })

        # Calculate total ROS points from adds
        tk_total_points = 0
        for add in tk_adds:
            for week in range(add['add_week'], current_week + 1):
                tk_total_points += calc.player_points_by_week.get(add['player_id'], {}).get(week, 0)

        all_team_waiver_contributions[tk] = tk_total_points

    # Use helper functions for ranking
    waiver_ranking = calculate_league_ranking(all_team_waiver_contributions, team_key, reverse=True)
    playoff_team_keys = get_playoff_teams(calc)
    playoff_comparison = calculate_playoff_comparison(all_team_waiver_contributions, team_key, playoff_team_keys)

    # Calculate estimated wins impact (~150 waiver points = 1 win)
    gap_to_playoff = playoff_comparison['gap_to_playoff_avg']
    estimated_wins_from_gap = gap_to_playoff / 150

    # ====================================================================================
    # THE HAUNTING: The ghost that won't leave you alone
    # ====================================================================================

    if worst_drops:
        biggest_drop = worst_drops[0]
        drop_player_name = biggest_drop.get('player_name', 'Unknown')
        drop_ros_points = biggest_drop.get('ros_points', 0)
        drop_week = biggest_drop.get('drop_week', 0)
        acquired_by = biggest_drop.get('acquired_by', 'Waiver wire')

        the_haunting = {
            'player_name': drop_player_name,
            'week_forsaken': drop_week,
            'what_they_became': f"Scored {drop_ros_points:.0f} points after you discarded them",
            'where_they_went': acquired_by,
            'the_mistake': f"You dropped {drop_player_name} in Week {drop_week}, thinking they were done. They weren't.",
            'the_ghost': f"{drop_player_name} haunts you. Every notification, every waiver claim by someone else, every start against you.",
            'unforgivable': drop_ros_points > 150,
            'cost': f"~{min(3, total_drop_impact // 50):.0f} wins lost to impatience"
        }
    elif total_adds < 5 and abs(gap_to_playoff) > 300:
        the_haunting = {
            'player_name': 'The waiver wire itself',
            'week_forsaken': 'All season',
            'what_they_became': f"{abs(gap_to_playoff):.0f} points behind playoff teams",
            'where_they_went': 'Into your rivals\' lineups',
            'the_mistake': f"You made only {total_adds} waiver moves all season. The wire was rich with talent. You starved.",
            'the_ghost': "Every breakout player you ignored whispers your name in the dark.",
            'unforgivable': abs(gap_to_playoff) > 500,
            'cost': f"~{abs(estimated_wins_from_gap):.1f} wins lost to inaction"
        }
    else:
        the_haunting = {
            'player_name': 'None',
            'week_forsaken': None,
            'what_they_became': 'You managed your roster prudently',
            'where_they_went': 'N/A',
            'the_mistake': 'No major drops haunt you',
            'the_ghost': "Your conscience is clear. For now.",
            'unforgivable': False,
            'cost': 'Minimal'
        }

    # ====================================================================================
    # THE BETRAYAL: How your forsaken players helped your enemies
    # ====================================================================================

    # Calculate which rivals benefited from your drops
    rivals_helped = {}
    for drop in drops_that_hurt:
        acquired_by = drop.get('acquired_by', 'Waiver wire')
        if acquired_by != 'Waiver wire':
            if acquired_by not in rivals_helped:
                rivals_helped[acquired_by] = {
                    'manager_name': acquired_by,
                    'players_taken': [],
                    'total_points_gained': 0
                }
            rivals_helped[acquired_by]['players_taken'].append(drop['player_name'])
            rivals_helped[acquired_by]['total_points_gained'] += drop['ros_points']

    # Find biggest beneficiary
    if rivals_helped:
        biggest_beneficiary = max(rivals_helped.values(), key=lambda x: x['total_points_gained'])

        the_betrayal = {
            'you_gave_them_away': len([d for d in drops_that_hurt if d.get('acquired_by') != 'Waiver wire']),
            'total_points_to_rivals': round(sum(d['ros_points'] for d in drops_that_hurt if d.get('acquired_by') != 'Waiver wire'), 1),
            'biggest_beneficiary': biggest_beneficiary['manager_name'],
            'what_they_got': f"{len(biggest_beneficiary['players_taken'])} of your discarded players for {biggest_beneficiary['total_points_gained']:.0f} points",
            'the_irony': f"You armed {biggest_beneficiary['manager_name']} with the weapons that helped defeat you.",
            'self_inflicted': True,
            'players_list': biggest_beneficiary['players_taken']
        }
    else:
        the_betrayal = {
            'you_gave_them_away': 0,
            'total_points_to_rivals': 0,
            'biggest_beneficiary': None,
            'what_they_got': 'Nothing significant',
            'the_irony': "Your drops stayed on waivers. No rival profited from your mistakes.",
            'self_inflicted': False,
            'players_list': []
        }

    # Rankings already calculated above (before the_haunting section)
    # No need to recalculate here

    return {
        'manager_name': team['manager_name'],
        'drops_analysis': {
            'total_drops': len(dropped_players),
            'drops_that_hurt': len(drops_that_hurt),
            'total_ros_points_given_away': round(total_drop_impact, 1),
            'worst_drops': worst_drops
        },
        'lost_bids_analysis': {
            'note': 'FAAB bid tracking requires detailed transaction data',
            'lost_bids_count': len(lost_bids),
            'estimated_impact': 'Low'  # Placeholder
        },
        'waiver_contribution': {
            # Core metrics
            'total_adds': total_adds,
            'total_points_added': round(total_points_added, 1),
            'total_points_started': round(total_points_started, 1),
            'usage_rate': round(usage_rate_overall, 1),
            'add_quality_score': round(add_quality_score, 1),
            'starter_conversion_rate': round(starter_conversion_rate, 1),
            'win_contribution': waiver_win_contribution,

            # PRIMARY METRIC: League context with rankings
            'league_rank': waiver_ranking['league_rank'],
            'league_rank_numeric': waiver_ranking['league_rank_numeric'],
            'percentile': waiver_ranking['percentile'],
            'league_avg_points': waiver_ranking['league_average'],
            'playoff_avg_points': playoff_comparison['playoff_teams_average'],
            'gap_to_playoff_avg': playoff_comparison['gap_to_playoff_avg'],
            'gap_to_league_avg': waiver_ranking['gap_to_average'],
            'estimated_wins_from_gap': round(estimated_wins_from_gap, 1),
            'grade': get_grade_from_percentile(waiver_ranking['percentile']),

            # Detailed adds (top 10)
            'top_adds': add_details[:10],

            # Summary verdict
            'verdict': {
                'category': 'Inactive' if total_adds == 0 else 'Very Active' if total_adds >= 30 else 'Active' if total_adds >= 15 else 'Moderate' if total_adds >= 5 else 'Passive',
                'impact': 'Critical Gap' if gap_to_playoff < -400 else 'Significant Gap' if gap_to_playoff < -200 else 'Minor Gap' if gap_to_playoff < 0 else 'Competitive' if gap_to_playoff < 100 else 'Elite',
                'summary': f"You added {round(total_points_added, 0)} pts from waivers (Rank {waiver_ranking['league_rank']}). Playoff teams averaged {round(playoff_comparison['playoff_teams_average'], 0)} pts. Your {round(gap_to_playoff, 0):+.0f} pt gap cost ~{abs(round(estimated_wins_from_gap, 1))} wins." if gap_to_playoff < 0 else f"You added {round(total_points_added, 0)} pts from waivers (Rank {waiver_ranking['league_rank']}). You matched/exceeded playoff teams ({round(playoff_comparison['playoff_teams_average'], 0)} pts avg)."
            }
        },
        'ecosystem_impact': {
            'players_given_to_rivals': len([d for d in drops_that_hurt if d.get('acquired_by') != 'Waiver wire']),
            'points_given_to_rivals': round(sum(d['ros_points'] for d in drops_that_hurt if d.get('acquired_by') != 'Waiver wire'), 1),
            'biggest_mistake': worst_drops[0] if worst_drops else None
        },
        'waiver_efficiency': {
            'total_adds': total_adds,
            'productive_adds': productive_adds,
            'meaningful_starters': meaningful_starters,
            'efficiency_rate': round(efficiency_rate, 1),
            'starter_conversion_rate': round(starter_conversion_rate, 1),
            'wasted_adds': total_adds - productive_adds,
            'note': f"{productive_adds} of {total_adds} waiver adds were productive (≥5 PPG when started)",
            'points_added': round(total_points_added, 1),
            'league_rank': waiver_ranking['league_rank']
        },
        'the_haunting': the_haunting,  # The ghost that won't leave you alone
        'the_betrayal': the_betrayal  # How your drops helped your enemies
    }
