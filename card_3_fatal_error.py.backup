"""
Card 3: The Fatal Error
Identify 2-3 pivotal moments that changed the season
"""

from collections import defaultdict
from league_metrics import (
    calculate_league_ranking,
    get_grade_from_percentile
)


def calculate_card_3_inflection(calc, team_key: str) -> dict:
    """
    Calculate Card 3: The Fatal Error

    Args:
        calc: FantasyWrappedCalculator instance
        team_key: Team key

    Returns:
        Dict with pivotal moments
    """
    team = calc.teams[team_key]

    # Use regular season weeks only (playoffs are different beast)
    regular_season_weeks = calc.get_regular_season_weeks()

    inflection_points = []

    # INFLECTION TYPE 1: Lineup Mistakes That Flipped Outcomes
    # Find weeks where bench player would have won/lost the matchup

    for week in regular_season_weeks:
        week_key = f'week_{week}'

        if week_key not in calc.weekly_data.get(team_key, {}):
            continue

        week_data = calc.weekly_data[team_key][week_key]
        actual_points = week_data.get('actual_points', 0)
        roster = week_data.get('roster', {})

        # Calculate optimal lineup
        optimal_result = calc.calculate_optimal_lineup(roster, filter_injured=False)
        optimal_points = optimal_result['optimal_points']
        bench_left = optimal_result['points_left_on_bench']

        # Get actual opponent data
        opponent_id = week_data.get('opponent_id', '')
        opponent_points = week_data.get('opponent_points', 0)
        opponent_name = calc.teams.get(opponent_id, {}).get('manager_name', 'Unknown')

        # Check if lineup mistake changed outcome
        actual_won = actual_points > opponent_points
        optimal_won = optimal_points > opponent_points

        if actual_won != optimal_won and bench_left > 5:
            # This was a pivotal lineup decision
            impact_type = 'Loss' if optimal_won and not actual_won else 'Win'

            # Find specific players involved (lowest starter vs highest bench)
            starters = roster.get('starters', [])
            bench = roster.get('bench', [])

            lowest_starter_name = 'unknown player'
            highest_bench_name = 'unknown player'

            if starters:
                lowest_starter = min(starters, key=lambda p: p.get('actual_points', 0))
                lowest_starter_id = str(lowest_starter.get('player_id'))
                lowest_starter_name = calc.player_names.get(lowest_starter_id, f"Player {lowest_starter_id}")

            if bench:
                highest_bench = max(bench, key=lambda p: p.get('actual_points', 0))
                highest_bench_id = str(highest_bench.get('player_id'))
                highest_bench_name = calc.player_names.get(highest_bench_id, f"Player {highest_bench_id}")

            inflection_points.append({
                'type': 'lineup_mistake',
                'week': week,
                'description': f"Week {week} lineup decision vs {opponent_name}",
                'impact': impact_type,
                'details': {
                    'actual_score': round(actual_points, 1),
                    'optimal_score': round(optimal_points, 1),
                    'opponent_score': round(opponent_points, 1),
                    'bench_points_left': round(bench_left, 1),
                    'wrong_starter': lowest_starter_name,  # NEW: Player name
                    'bench_player': highest_bench_name,  # NEW: Player name
                    'margin': round(abs(actual_points - opponent_points), 1),  # NEW: Margin for consistency
                    'outcome': f"{'Won' if actual_won else 'Lost'} with actual lineup, would have {'won' if optimal_won else 'lost'} with optimal"
                },
                'win_impact': 1 if (optimal_won and not actual_won) else -1
            })

    # INFLECTION TYPE 2: Close Losses Where Small Changes Mattered
    # Games lost by < 10 points where a bench player could have changed outcome

    for week in regular_season_weeks:
        week_key = f'week_{week}'

        if week_key not in calc.weekly_data.get(team_key, {}):
            continue

        week_data = calc.weekly_data[team_key][week_key]
        actual_points = week_data.get('actual_points', 0)
        roster = week_data.get('roster', {})

        # Get actual opponent data
        opponent_id = week_data.get('opponent_id', '')
        opponent_points = week_data.get('opponent_points', 0)
        opponent_name = calc.teams.get(opponent_id, {}).get('manager_name', 'Unknown')

        # Check for close loss
        margin = actual_points - opponent_points

        if -10 < margin < 0:  # Lost by less than 10 points
            # Find bench player who could have changed it
            bench = roster.get('bench', [])
            starters = roster.get('starters', [])

            # Find lowest-scoring starter
            if starters:
                lowest_starter = min(starters, key=lambda p: p.get('actual_points', 0))
                lowest_starter_points = lowest_starter.get('actual_points', 0)
                lowest_starter_id = str(lowest_starter.get('player_id'))
                lowest_starter_name = calc.player_names.get(lowest_starter_id, f"Player {lowest_starter_id}")

                # Find highest-scoring bench player
                if bench:
                    highest_bench = max(bench, key=lambda p: p.get('actual_points', 0))
                    highest_bench_points = highest_bench.get('actual_points', 0)
                    highest_bench_id = str(highest_bench.get('player_id'))
                    highest_bench_name = calc.player_names.get(highest_bench_id, f"Player {highest_bench_id}")

                    swap_diff = highest_bench_points - lowest_starter_points

                    if swap_diff > abs(margin):
                        # This swap would have won the game
                        inflection_points.append({
                            'type': 'close_loss',
                            'week': week,
                            'description': f"Week {week} heartbreaker vs {opponent_name}",
                            'impact': 'Loss',
                            'details': {
                                'margin': round(abs(margin), 1),
                                'wrong_starter': lowest_starter_name,  # NOW WITH NAME
                                'wrong_starter_id': lowest_starter_id,
                                'wrong_starter_points': round(lowest_starter_points, 1),
                                'bench_player': highest_bench_name,  # NOW WITH NAME
                                'bench_player_id': highest_bench_id,
                                'bench_player_points': round(highest_bench_points, 1),
                                'swap_difference': round(swap_diff, 1),
                                'explanation': f"Starting {highest_bench_name} ({highest_bench_points:.1f} pts) over {lowest_starter_name} ({lowest_starter_points:.1f} pts) would have won by {swap_diff - abs(margin):.1f}"  # NEW: Context
                            },
                            'win_impact': 1
                        })

    # INFLECTION TYPE 3: High-Impact Weeks (scored way above/below average)
    # Find weeks where unusual performance changed trajectory

    team_weekly_scores = []
    for week in regular_season_weeks:
        week_key = f'week_{week}'
        if week_key in calc.weekly_data.get(team_key, {}):
            points = calc.weekly_data[team_key][week_key].get('actual_points', 0)
            team_weekly_scores.append((week, points))

    if team_weekly_scores:
        avg_score = sum(s[1] for s in team_weekly_scores) / len(team_weekly_scores)

        for week, score in team_weekly_scores:
            week_key = f'week_{week}'

            # Get actual opponent data for this week
            week_data = calc.weekly_data[team_key][week_key]
            opponent_points = week_data.get('opponent_points', 0)

            won = score > opponent_points
            deviation = score - avg_score

            # Flag weeks with >30 point deviation from average
            if abs(deviation) > 30:
                inflection_points.append({
                    'type': 'boom_or_bust',
                    'week': week,
                    'description': f"Week {week} {'explosion' if deviation > 0 else 'disaster'}",
                    'impact': 'Win' if won else 'Loss',
                    'details': {
                        'score': round(score, 1),
                        'avg_score': round(avg_score, 1),
                        'deviation': round(deviation, 1),
                        'result': 'Won' if won else 'Lost'
                    },
                    'win_impact': 1 if won else -1
                })

    # Sort inflection points by absolute win impact
    inflection_points.sort(key=lambda x: abs(x.get('win_impact', 0)), reverse=True)

    # Take top 5 most impactful moments
    top_inflections = inflection_points[:5]

    # Calculate cumulative win impact
    total_win_impact = sum(ip.get('win_impact', 0) for ip in top_inflections)

    # Categorize inflections
    lineup_mistakes = [ip for ip in top_inflections if ip['type'] == 'lineup_mistake']
    close_losses = [ip for ip in top_inflections if ip['type'] == 'close_loss']
    boom_bust = [ip for ip in top_inflections if ip['type'] == 'boom_or_bust']

    # Identify the single biggest mistake (preventable loss with highest impact)
    biggest_mistake = None
    for ip in top_inflections:
        if ip['type'] in ['lineup_mistake', 'close_loss'] and ip['impact'] == 'Loss':
            biggest_mistake = ip
            break  # First one is already sorted by impact

    # ====================================================================================
    # THE MOMENT: The single decision that sealed your fate
    # ====================================================================================

    preventable_losses = [ip for ip in top_inflections if ip['impact'] == 'Loss' and ip['type'] in ['lineup_mistake', 'close_loss']]
    total_preventable_wins = sum(ip.get('win_impact', 0) for ip in preventable_losses)

    if biggest_mistake:
        mistake_type = biggest_mistake['type']
        mistake_week = biggest_mistake['week']

        if mistake_type == 'lineup_mistake':
            bench_left = biggest_mistake['details'].get('bench_points_left', 0)
            wrong_starter = biggest_mistake['details'].get('wrong_starter', 'unknown player')
            bench_player = biggest_mistake['details'].get('bench_player', 'unknown player')
            margin = biggest_mistake['details'].get('margin', 0)

            the_moment = {
                'week': mistake_week,
                'the_error': f"You started {wrong_starter} over {bench_player}",
                'the_consequence': f"Lost by {abs(margin):.1f} points. {bench_left:.1f} points left rotting on your bench.",
                'the_what_if': biggest_mistake.get('description', 'One different decision changes everything'),
                'irreversible': True,
                'haunts_you': f"Week {mistake_week} will haunt you all off-season"
            }
        else:  # close_loss
            margin = biggest_mistake['details'].get('margin', 0)
            wrong_starter = biggest_mistake['details'].get('wrong_starter', 'a player')
            bench_player = biggest_mistake['details'].get('bench_player', 'a bench player')

            the_moment = {
                'week': mistake_week,
                'the_error': f"Started {wrong_starter} instead of {bench_player}",
                'the_consequence': f"Lost by {abs(margin):.1f} points in a game you should have won.",
                'the_what_if': f"One roster swap and you win. But you didn't make it.",
                'irreversible': True,
                'haunts_you': f"This {abs(margin):.1f}-point loss defines your season"
            }
    else:
        # No single fatal error
        if len(boom_bust) > 0:
            the_moment = {
                'week': None,
                'the_error': f"{len(boom_bust)} weeks of extreme volatility",
                'the_consequence': "Your roster was a slot machine. Sometimes it hit. Often it didn't.",
                'the_what_if': "A more consistent roster would have smoothed the chaos.",
                'irreversible': False,
                'haunts_you': "Volatility is not a strategy"
            }
        else:
            the_moment = {
                'week': None,
                'the_error': "No fatal error",
                'the_consequence': "Your season unfolded predictably. No single moment changed your fate.",
                'the_what_if': "There is no alternate timeline where one decision saves you.",
                'irreversible': False,
                'haunts_you': "Your problems are structural, not situational"
            }

    # ====================================================================================
    # PRIMARY METRIC: Average Bench Points Gap (League Comparison)
    # ====================================================================================

    # Calculate this manager's average bench gap
    current_week = calc.league['current_week']
    total_bench_gap = 0
    weeks_counted = 0

    for week in regular_season_weeks:
        week_key = f'week_{week}'
        if week_key in calc.weekly_data.get(team_key, {}):
            week_data = calc.weekly_data[team_key][week_key]
            roster = week_data.get('roster', {})
            optimal_result = calc.calculate_optimal_lineup(roster, filter_injured=False)
            total_bench_gap += optimal_result['points_left_on_bench']
            weeks_counted += 1

    avg_bench_gap = total_bench_gap / weeks_counted if weeks_counted > 0 else 0

    # Calculate for all teams to get league ranking
    all_team_bench_gaps = {}
    for tk in calc.teams.keys():
        tk_total_bench = 0
        tk_weeks = 0

        for week in regular_season_weeks:
            week_key = f'week_{week}'
            if week_key in calc.weekly_data.get(tk, {}):
                week_data = calc.weekly_data[tk][week_key]
                roster = week_data.get('roster', {})
                optimal_result = calc.calculate_optimal_lineup(roster, filter_injured=False)
                tk_total_bench += optimal_result['points_left_on_bench']
                tk_weeks += 1

        all_team_bench_gaps[tk] = tk_total_bench / tk_weeks if tk_weeks > 0 else 0

    # Rank (lower bench gap is better, so reverse=False)
    bench_gap_ranking = calculate_league_ranking(all_team_bench_gaps, team_key, reverse=False)

    # ====================================================================================
    # THE RECKONING: What this moment cost you in cold numbers
    # ====================================================================================

    # Get calculated stats from weekly data (not stale team summary)
    calculated_stats = calc.calculate_team_stats_from_weekly_data(team_key)
    actual_wins = calculated_stats['wins']
    actual_losses = calculated_stats['losses']

    the_reckoning = {
        'total_inflection_points': len(top_inflections),
        'preventable_losses': len(preventable_losses),
        'wins_lost_to_mistakes': total_preventable_wins,
        'pattern': 'Lineup management issues' if len(lineup_mistakes) > len(close_losses) else 'Close games slipping away',
        'the_math': {
            'actual_record': f"{actual_wins}-{actual_losses}",
            'if_you_fixed_mistakes': f"{actual_wins + total_preventable_wins}-{actual_losses - total_preventable_wins}",
            'games_stolen_from_yourself': total_preventable_wins
        },
        'diagnosis': 'Multiple preventable mistakes' if total_preventable_wins >= 3 else 'A couple of avoidable losses' if total_preventable_wins > 0 else 'Few preventable mistakes'
    }

    return {
        'manager_name': team['manager_name'],
        'inflection_points': top_inflections,
        'biggest_mistake': {
            'event': biggest_mistake if biggest_mistake else None,
            'tagline': f"Week {biggest_mistake['week']}: {biggest_mistake['description']}" if biggest_mistake else "No major preventable mistakes",
            'note': 'This single decision had the biggest impact on your season'
        },
        'summary': {
            'total_inflection_points': len(top_inflections),
            'lineup_mistakes': len(lineup_mistakes),
            'close_losses': len(close_losses),
            'boom_bust_weeks': len(boom_bust),
            'cumulative_win_impact': total_win_impact,
            'biggest_what_if': top_inflections[0] if top_inflections else None
        },
        'insights': {
            'preventable_losses': len(preventable_losses),
            'total_preventable_win_impact': total_preventable_wins
        },
        'bench_gap_metric': {  # PRIMARY METRIC
            'total_bench_points_left': round(total_bench_gap, 1),
            'avg_bench_gap_per_week': round(avg_bench_gap, 1),
            'league_rank': bench_gap_ranking['league_rank'],
            'league_rank_numeric': bench_gap_ranking['league_rank_numeric'],
            'percentile': bench_gap_ranking['percentile'],
            'league_average': bench_gap_ranking['league_average'],
            'gap_to_average': bench_gap_ranking['gap_to_average'],
            'grade': get_grade_from_percentile(bench_gap_ranking['percentile']),
            'note': 'Lower is better - measures lineup optimization'
        },
        'the_moment': the_moment,  # The single decision that sealed your fate
        'the_reckoning': the_reckoning  # What it cost you in cold numbers
    }
